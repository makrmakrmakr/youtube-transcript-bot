- English (auto-generated)

- Generated by YouTube: True

hey guys what's up so welcome to this
tutorial series
on flask so in this tutorial series we
are going to be building
a link bookmarking api such that users
can be able to
save links that they may want to check
out in the future so our backend is
going to be multi-user meaning that we
are going to need a
way for users to be able to create
accounts and also to log in
so when they log in we will be giving
them an access token that they can use
to access the protected endpoints like
the ones to create a bookmark
to retrieve all bookmarks so we'll also
have another
endpoint that is going to be used to
refresh a token
for security purposes the access token
that we get on login will be short-lived
so whenever user logs in we are going to
give them a pair of keys
an access token and a refresh token so
whenever the access token expires
we are going to be using that refresh
token to make a call to the
to the token refresh endpoint where we
can get
a new access token and keep our users
logged in what we are looking at right
now is the api documentation
and we are going to be using swagger to
document it
so every endpoint we add in the backend
will will have to be documented
somehow such that we can be able to give
this documentation to like other
developers that might want to make a
mobile app for this api
or if they want to make a front-end
using react or angular or vue
or whatever the front-end developers
have these days
they can use this to know how to talk to
api and they can
make it work for the user so here in
postman you can see that over here we go
ahead and make a request to the
sign up endpoint and we get a 201
created which means that a resource was
created on our server
and then we get a response of that user
send back then from the endpoint to
login
we get the two tokens and then we get
the other extra
users information who has logged in and
then with these tokens
we can start to access protected
endpoints like this one to get a list of
bookmarks
this one to add a bookmark one thing
you'll notice here is on the period of a
single bookmark
we have a short show area and a long url
and also we have the visits
property so the visits property is used
to track
how many times we visited this url
because it's common that we might
bookmark things but we might not check
them out
so this is going to be used to give the
user an insight on the things they have
not checked out
so the way we are doing that is by in
the backend implementing
a url shortener service
so over here you can set we have a field
for the short url
so whenever a user enters a url like
this we go ahead and shorten it on our
server
and on our server we create a unique url
for it
so now when i try to access let's say i
want to access this
localhost 455 slash z5b
if i go to a chrome and i type it like
here
notice that this should be going to our
local server but when i click there
you notice that it goes to our server
and then it redirects
here to the real to the real
url so this way we are able to tell that
the user actually checked out one of the
links they bookmarked
by having to implement the shortener
service so it's it's quite interesting
how it's implemented so
i'm sure you're gonna learn some cool
things as we implement that
now over here we have an endpoint for
retrieving the stats
you can see that for each of the urls we
can track how many times it was visited
such that maybe on the front end we can
sort our
bookmarks by the ones we've not checked
out so we make our backend api
more flexible and more realistic so that
is going to be it for the introductory
video
if you are really interested in building
these kinds of apps i highly recommend
you subscribe to the channel
because i'm going to be releasing a lot
of videos showing you guys how to build
these kinds of apis mobile apps web apps
from scratch
so please consider subscribing thanks
and i'll see you in the next video
so in this video we're going to go ahead
and create our first project
and make sure that you can get started
writing card so to get started the only
requirement you're going to need here is
python
so make sure you have python installed
when you install python with the normal
process
you're going to have pip and then we are
going to be using pip to install our
our project dependencies like flask and
alike so to get started i'm here in my
terminal so if you're on a mac or linux
open up your terminal if you're on
windows
open up your command prompt but first
you want to first verify that you have
python
so go ahead and type in python in your
terminal
when i type in python you can see that i
get the python share open up
by default it opens up python 2 so this
is not what we want so i'm going to quit
here
now on macro linux when installed python
3 you can use that by typing in python 3
so when i type in python 3 you can set i
have python 3.7.7
so let me just click this one again so
verify that you have python
so if i do python 3 version
you can set i have to you can see my
version
now to check if you have pip you can
type in pip
so since i'm using a mac you can type in
pip3
version and then you can see that we get
pip3 version being listed so if you're
in windows
be sure to you to type in pip or python
without putting the three
it should be able to work automatically
if you install following the
default process so once you have that we
are going to need a way to manage our
virtual environment
now if you think about python projects
you might be working on
like two or three python projects on
your computer and a lot of the times you
want each of those projects
to have its own dependencies in one
place such that you can be able to move
the project around computers or even
put it on a server for hosting without
having to
look for the packages again so we are
going to be creating a virtual
environment that will hold all our
project dependencies now for us to
create a virtual environment you're
going to be
using a tool called virtual env so if
you're on mac or linux
go ahead and install it using pip3 so
you can type in peep 3d install
version env like this so go ahead and
run that
so when i run that you can set mine
finished so fast because i already had
it
on windows go ahead and type in pip
install
virtual pnv
so once you install that now we can use
battery and
create a batch environment so over here
i'm first gonna create a folder that
will contain all our project files
so i'm gonna call this bookmarks rest
api and then i'm gonna cd into it so
bookmarks
so now that we are in our bookmarks rest
api we can go ahead and create our
virtual environment in here
so to create a batch environment we can
use the tool we just installed so
type in virtual env and then you give it
an environment name so mine is going to
be called v
e and v like this notice how i'm unable
to create it like this
so if you ever face that issue be sure
to run this using
python 3 so you can do python 3 minus
m m is for module signifying that we
want to run
this module using python three so i'm
going to run that
and when you run that you can see that
now if i do an errors
on windows you have to type in like a
dir to see
if the folder was created so if i do an
ls you can see that now we have the
folder
for our batch environment and now we
need to activate it
so now to activate it on the linux go
ahead and type in source
then vnv then go to bin
then you want to source in the activate
script this one
so when i do that you can see that my
virtual environment is activated and we
can tell
by seeing the name of the virtual
environment here
so if you ever want to maybe deactivate
it
you can type in deactivate
and it should deactivate it so if you're
in windows and you try typing in source
it will not work
be sure to cd into your virtual
environment then scripts then activate
the platform
and then you should be able to see that
your version your virtual environment is
activated like this
so now we are here if we do a python
version you can see that the python
we're using now
is the one that is tied to our project
and we don't have to do python 3 anymore
and if you ever wanted to know which
part which python you're using or
the where the python using is you can
type
which python and then you should be able
to see
where it is so the one are using is in
our virtual environment
so good now let's go ahead and install
flask so it installed first go ahead and
do pip
install flask like this so it's going to
go ahead and install flask
so flask also uses some other
dependencies
so you can see that it installs like
ginger too it's dangerous
click typing extensions
flask also depends on this now our
project also depends on these with flask
so now that we have flask installed i'm
going to open up this project in vs code
so on my computer i can type in chord
dot and then it should be able to open
in vs code so you can see here we have
our project
and then we have the virtual environment
so i'm going to open the integrated
terminal in vs code because with this
one i don't have to switch between
windows i can just code
i can just work in one editor and things
will be fine
so over here the first thing you're
going to need to do is we are going to
create
an entry point to our server so out here
i'm going to create a file called
app.pi so in the update this is where
we're going to be writing our python
code
but before we do that let me go ahead
and activate my virtual environment
again because
when you open a new terminal session you
have to reactivate the virtual
environment so let me go ahead and do
that
so so now we are going to go ahead and
we create
a very basic flask app so to create a
very basic flask cap we are going to
import flask
from flask so from frask import
flask so here we need to create an
instance of flask and that will be our
app so we can do like app
equals flash and then we pass in double
underscore
name double underscore so when we
instantiate flask it needs a way to know
where it is being
configured from and that's why you're
passing this this then the name data
so once we are done with this now we can
go ahead and recreate a very
basic route so this can sometimes be
called an endpoint
and we can create that by using the app
and then we use a decorator
we do app dot and then after this we do
an http method so for example if we
wanted to do a get request we'll do
app.get and then inside here and then
we'll find the route
so we are going to listen for when a
user goes to our home page
and then we're going to create a
function to handle that so here we can
just have a function
so for this function we're going to just
be returning hello world
hello world like this
so don't mind this so now to be able to
test out our application if
to be able to run it we need to go in
our terminal and then we need to tell
flask
a few things one of them is going to be
the environment we are running in
so over here we can do export flask
underscore and then we are going to set
that one to
development so by default flask will
assume that we are running in production
so you need to tell it that we are
running in development so that it can
give us like debugging errors and all
that stuff
so let's run that so another thing we
need to define is the path to our
flask app so we can do that by doing
export flask
app and then and that will be the part
of the module that has our first cap in
our case it is app
so we can do up like this and now we can
run flask
run in our terminal and once we run that
you should be able to see that we have
serving flask app
and then we have the environment you're
running on which is development and then
that turns on like debug mode
and all this other stuff so now if we
click on this url
and come to the browser you can see that
we have our hello world
now the browser can only help us to do
get requests
but later we're going to be looking at
how to use postman to also work with
other
methods like like post or delete or get
so let's have another basic endpoint
over here
so i'm going to have slash hello so
since we are going to be building an api
then it makes sense to start working
with json already
so over here so flask comes with some
utilities that can enable us to work
with
json and one we are going to be working
with is jsonify
so we want when a user goes to this
error route
we want to send them a message so we're
going to send back a python dictionary
now we can do just one file here we can
wrap everything here in jsonify
so we're going to change the function
name that handles this so they don't
collide so we're gonna have
say hello so we're gonna have say hello
on there
and now if you go back to application
and now we go to the error route
you can start we get json being sent
sent back to us so one thing here that i
want to point out is so by default
flask is going to format this into json
even when we don't use jsonify
so even if we take this one away so let
me take this one away again
and come back over here to slash hello
you can see that it works the same
so the python dictionary is directly
mapped to a json object
and we don't really have to to do any
other extra
serialization for this so that's gonna
be it for the setup if you're on windows
and you get any issues
be sure to check that be sure to check
the description i will leave some tips
in there
also check the comments because i'm sure
some guys are gonna be
laying down how things should be done
hey welcome back guys so in this one
we're gonna be talking about quite a
number of things
one is we're going to work on our folder
structure making sure
make sure we are structuring things very
well and then we are going to see an
alternative way to set up an
app by using factory functions and also
we are going to be taking a look at the
flask
f and how to manage environment
variables so over here what we did was
we created an instance of our app by
just setting it to flask
and then we are using this app almost
everywhere so we could go ahead here and
we connect our app to like a database
and all that stuff
but that approach will have some
drawbacks because that way we might not
be able to
easily test our application what we're
going to do now is we're going to set it
up
in a way that it can accept different
configurations depending on how it is
being run
so over here i'm going to start by
creating a few files and folders
so the first thing i'm going to do is
i'm going to create an src folder
so the src folder will host all our
application code so all the code we
write will go in the src folder
so over here i'm going to move this up
of course now to the src because now
all application code will be here and
then over here i'm going to create some
other folders
one is going to be the config folder so
the config folder will host all the void
upgrade configuration
for the different modules we are going
to be working with so also i'm going to
create another folder here
called constants so inside here we can
have some constants for example some
variables that we don't want them
so we don't want to change across our
apps for example the status quo so i'm
just going to create here status codes
dots by file already so
i'm actually going to prefix it with
http
just so we don't confuse that and then
the other folder i'm going to create
here is the static and the templates
folder
so this we can use them if you wanted to
like a web page maybe
a welcome page it would need us to have
like some css so we'll put the thing
here
let me also have some templates so in
the templates we can have some html if
we needed to
so also i'm going to create a services
folder
so in the services let's say we wanted
to send an email to the user when they
sign up
we could have like an email service
inside there
so one thing i'm going to do is outside
the src i'm going to create a tests
folder so i'm going to have tests
there so if we wanted to write some unit
tests or some other types of tests
we'll put them in there and now in the
source this is where we're going to
create our
factory function the one that is going
to set up our app
so over here i'm going to create a data
init file
so this is the file you can think of
this as the default file
so whenever importing from source we
don't have to put data in it every time
we import from source
this is going to be imported
automatically so over here we're going
to have a function that's going to be
responsible to create our app set up
some configurations and then return it
to us
depending on how we intend to call that
function so this function is going to be
called create app now this function is
going to be taking in a config
now the common two cases that i find
when writing apps is when you have to
configure it for
for testing or when you want to to use
it
as a user so over here when we call it
you're going to be passing it a test
config
so i'm going to set it to none by
default so over here now we can create
our app that just like the way we did it
in app
so let's import this actually let's just
import all this
because we're going to need to do the
same thing i always have to have all my
inputs on top although with python you
can have them anyway
so we're gonna have app equals
flask and then i'm gonna pass in another
argument here
and that argument is gonna be instance
relative config
so instance relative config and then
we're going to set that one to true
and that just tells us that we might
have some configurations that are going
to be defined in some files outside here
so now that we have that then we can go
ahead and check if we are running in
testing or if we have some testing
config
we can say if this thing is none we can
go ahead and configure our app now one
thing i'm going to configure quickly is
the secret screen
so over here we can do app dot config
then we want to do from mapping so when
we do from mapping then we can pass in
our configurations
so for now i'm going to set the secret
key so i'm going to do secret key
and then i'm going to set that one to
dev for now and then later i'm going to
be showing you how to use environment
variables to
pull this one in if we wanted to like
set up a database or maybe configure our
app to use
our app to work with another module
we'll be doing that in the
in this block but if the test config is
defined
then we are going to go ahead and have
an lcn and then we are going to be
running our app using that configuration
so you can do upload config that from
mapping
and then we can use the one that we
passed in when we created our app we
need to return our app so we can
return up like this now in the app.py
since we have
these functions of ours right now we
have another instance of our app so
we're going to clear this one away
and to keep things working over here in
our app we're going to have this
defined so let's push them in here
so we can have that index and this and
the add error
and now we need to tell flask to now use
this file as our main app entry point so
i'm going to stop the server and run
export class app and then we can so now
we are going to set our new path which
is in
src so you can do flask app equals src
and now if we run back our app first run
you can see that our server is still
on and when we come over here because
that we still have our hello world
and we can still go back to slash along
and get the message so which is good one
thing you must have noticed is i have to
update flask in the terminal by setting
the path to the flask up again
what happens is whenever we want to run
let's say first run in another terminal
now let's say i wanted to run this app
in a new terminal so i'm going to go to
a new one a fresh one
so if we do flask run over here it
doesn't locate the flask application so
instead of us having to go ahead
repeating this setting the flask app
setting the environment every time we
have a new terminal session
what we can do is we can create a
special file called dot flask m
so in the flat scan file then we can
have all our configurations the one we
are setting from the terminal
so let's see the environment so export
flask f equals development
let's also set the first app so export
flask underscore app
and this is going to be src and now if
we come back to a new terminal session
in fact i'm going to create a new one
and now if we do flask run you'll notice
that they tell us that there is a dot f
or a first game file and for frost to be
able to work with this new file we need
to have python.nb installed
so i'm going to copy this command here
and run that
in our environment just so we can get it
installed
so it's going to go ahead and install
that so when it's done and we run back
our flask
notice that now our application starts
and it picks up the config
so it's now using development and we
don't have to actually go ahead and
set these ones again every time we are
rerunning it in a new terminal session
so that's how you do that one thing i
want to say about the flat scan file
is that uh that flask m5 is not a
replacement for a dot m file so in the
flask m file we can have some
configurations that we might be free to
even push the version control now also
we might have some files that we might
not want to push the version control
and those we can put them in a dot env
file so i'm going to create the tnv file
so here i'm going to have export secret
key
and we're going to talk more about
secret keys in a few
and now here where we set up our
application with the secret key
instead of us using this hard coded one
i'm going to use a noise module to read
from
the the current.env so i'm going to
import os here so import os
and over here then we can set this one
to
os dot inf environ
then we can do get then we can get the
key
so our key is secret key so we can make
sure that
we are getting that secret key so that's
how you get started with
application factory functions and also
how to work with
environment variables so if the video
helps you out be sure to give it a
thumbs up
don't forget to subscribe i'll talk to
you in the next video
thanks for watching bye
hey guys welcome back so in this one
we're going to go ahead and start
modularizing our project
by using blueprint so with blueprints
we're going to be able to create
different modules that then we can
register with our main first
app so we can keep our application
modular
one thing you have to keep in mind is
blueprints are meant to group
related functionality together so you
don't have to
have like a blueprint for users and then
the users you're doing like
a product list so you always want to
make sure that each blueprint is
is containing code that is related to
each other
so instead of us having these routes
here these were for testing i'm going to
get rid of them
so to get started creating our first
blueprint we are going to have a user's
blueprint and also the bookmarks
blueprint so in the source i'm going to
create a
an auth dot by
and also the bookmarks py file now to
define a blueprint we are going to need
blueprint so from flask
import blueprint okay
so to create our own we're going to call
our own auth and then
you want to call blueprint and then when
you call this notice that we can pass in
some config
and the one that is very obvious is the
name so we can do name
so we can do actually we can do name
equals author we can just pass it in
since it's positional so let's pass
let's call this one both and then we
need to tell it where it is being run
from so we can do that by passing down
the name
and then we can pass other configuration
for example notice that on our api
for us to hit the endpoints that are
going to be in auth we are going to be
doing like our our app search api
slash v1 slash auth so we can specify
a url prefix so here we can have
something like slash api
search v1 and now once we define a
blueprint then we can have
routes on it so if you wanted to handle
like a register or a signup request
would have at off
then we can handle the post and then for
this
then we can we can detect when a user is
going to register
and then we can handle that like this so
let's have function register
and then over here we can return
something like
user created and then of course we're
going to be coming back here
to make sure we can put there's some
meaningful logic
let's also have a function that gets the
current login user for it it's going to
be a gate so you can have
it get so you can have like slash main
then we can have a function to under
that we're gonna have like me you can
return
user you can turn there like user
name okay so we want to now create
the same thing this should be registered
we're going to now create a blueprint
for
bookmarks so you can go to our bookmarks
with py and have the same thing
so we're going to change off to
bookmarks almost everywhere
so we can change this one to bookmarks
so what we're doing
are getting the blueprint just so we can
create a blueprint and then we are
creating a bookmarks blueprint
then we are prefixing all the urls to
just start with api v1
bookmarks and then over here we can just
do slash register and that is going to
be appended here so we don't have to
repeat this part
more than once so here let's just have
a get let's just
bookmarks get slash and then this should
return
and then let's call this one index
or we can call this one get or let's
just return an empty list
so and then we're going to be adding to
this later
so after you find your blueprints then
you want to register them on your app
instance so here before we here before
we return our app
let's go ahead and implement and import
our blueprints
so from those so from source
we're going to use and we are going to
use an
absolute import so we're going to do
import
this also imports bookmarks from source
bookmarks imports
bookmarks so over here to return the app
we can just do
app put register blueprint
and then we want to register the oauth
one and then we're going to have to
register the bookmarks one
okay so once we're done with this now we
can go back to our application so i'm
going to go to
the application over here and now if we
go to slash
api slash v1
slash me oh search
notice that we get our code from the
blueprint
being executed and now if we go to slash
difficult slash bookmarks the index
route
because that we get an error so let's
check why we have this error here
so in bookmarks we are just returning a
list so we can't return it like this
so what you can do is return as we
return a dictionary
with the key and the value so we can
have like bookmarks in here
and then we set that one to empty so if
we come back and refresh this you can
set now we get
the response being sent so that's how we
modulate our app
now there's more config you can sit here
so be sure to look up how to
to maybe do something with book with
blueprints if you have a special use
case
so i hope this was helpful if it was
consider giving the video a thumbs up
don't forget to subscribe i'll talk to
you in the next video
hey guys welcome back this time i'm able
to organize a application
using blueprints so in this video i'm
going to go ahead and set up a database
that's going to be able to contain our
data about users
and also bookmarks so we are going to be
using flask sql alchemy
which is an extension for flask that
adds support for sql alchemy
so simple alchemy facilitates connecting
python programs to
different databases and it can also be
used as an object
relational mapper which gives us a layer
of obstruction
when we are interacting with databases
from our applications
so we don't have to write like the grade
the details of the sql
so we can just focus on writing or
python code and move faster
so over here in our source i'm going to
create a file called database
ui now we need the first install first
flask simple arching
now to install this we want to run
people install flask simple alternate
so i'm going to stop my server on here
make sure you're still in your virtual
environment
and then run this installation command
so after it installs the first thing
you're going to need to do is to set up
our db
and then tell super arch me on how to
connect to it
so we're going to be using sqright which
is a file based relational database
so good thing with this is it comes
bundled with a python
already so we don't have to go through
the process of installing postgresql
and you will see that for the case we
are going to be doing here we can pretty
much do it with any kind of database
but be sure to not use a file based
database
when you're going to make a a big app or
the app you're going to put to
production so over here to get started
we want to import simple argument from
flask super archimedes so what we need
to do here is we need to create our tv
and then we set it to
sql and then once we create our db then
on the db we have
we have access to the model class that
enables us to define how our relation
should look like
so over here we can create a class so
this class we can call it user
so we're gonna now define our how our
user relation is gonna be
or our user table so we're gonna inherit
from tp
dot motor okay so down in here now we
can define our columns
so for the columns you're going to of
course have an id so that would be like
the
unique identifier for each user so here
we can say db.column
so for the user we want the user to be
so we want the id to be an integer
for example one two three four five so
here you can do
db dot integer and then we are going to
set primary key equals true
and this is going to enable sql argument
to restrict this to only contain unique
values
also it's going to also since it's an id
it's going to be assigned
automatically by incrementing by
incrementing the id of the previous
object
it's going to be managed behind the
scenes for us then the next thing we're
going to have is the username
so over here let's just say username so
the username is going to be
a string so we can we have string
and then inside here we can define how
long we want it to be take the maximum
number
so let's have so let's have our
usernames to be
less than 80 so it's not going to be
primary but it's going to be unique
so we don't want our users to have the
same usernames
so next thing we're going to have to
define is the email
so we also have to specify that this
shouldn't be now
we don't want to create a user without a
name so we can specify inaudible because
false okay
so let's also specify the email
so i'm going to change this one to email
so it's going to be a string yes
now an email might be longer but let's
just take our hours to 120 it should be
unique
it also shouldn't be narrable it's also
defined the user's password
so for the password it can be a string
we also have another type for text so
that allows you to store strings without
having to limit them
so for the password of course you don't
want it to be unique
because you're going to be actually
hashing it as you'll see we won't be
storing it as a
like print text so let's also go ahead
and define the creator that it's very
important we
get to know when this was created so for
the type it's going to be a date time
field
we want every time a user is created we
want to enter this
automatically using the current date at
that time
using the current date at that moment
so over here we can also specify a
default
and then we can set this one to
datetime.now so i'm going to import the
time up here
import datetime then we can set this one
to
datetime dots now okay
so we'll also have the updated ad so i'm
going to duplicate this
so this is going to keep track of when
this item will just update it
so updated that will be the date time
but here we can satisfy on update
and then on updates we'll also be
inserting in time at that point so one
thing that we'll most likely want to do
is create a single representation a
string representation of our model class
so over here i'm going to have it under
reference method so for this one we're
going to be returning itself
the username so to make this one look
better i'm going to use f strings here
so i'm just going to do this then here
i'm going to have user now we have this
then for the dynamic variable you can
put it in this
curry brackets so this is how the class
would look now we are going to be adding
there some
other relationships but let's first go
and define our relation for the
bookmarks
so we're also going to have a class
called bookmark now you notice that
still we are naming our model classes
we are just using like singular terms
just like other python classes
these are no exception they have to
follow the standard convention
of naming classes that's why we name it
as a single entity
so now let's go ahead and define how our
bookmarks will be
so first off we're going to have a 19 so
the id is going to look similar to this
i'm just going to bring this one in then
the next thing you're going to have is a
the body of a bookmark so someone can
have some
some details so buddy you can just get
the text
so let's make it malleable so if a user
doesn't provide it
they app shouldn't complain let's also
pick the url
that is very important to us that is
what makes our application
work so for the url we will keep a text
and we want it to always be there we are
going to need to have a way of getting a
short version
a short url version of our main url
so that is something we're going to be
adding within our application so the
user won't have to supply it but for the
constraints here we're going to use a
string
and for this it's going to be a maximum
of three characters
so when we generate it we are going to
always make sure it is three and before
we insert it here
another thing we are going to define is
the visits
so we are also going to have to track
how many times a bookmark was checked
out
so for the visits you can have db
program
it's going to be an integer let's set
the default so default
it's going to be 0. now let's have they
updated it and created that so they are
going to be the same so i'm going to
copy these and also bring them
yeah so let's now talk a bit about
relationships
and how we can create a relationship
between a user and a bookmark
such that querying our records becomes
more efficient so what we're going to do
here on a bookmark we're also going to
specify
a user id and then this is going to be
an integer field so let's see here we
can do
db.integer we will also specify that
it's going to be a foreign key so the db
the foreign key
now when you do db dot foreign then you
can specify the table
that you're referencing in here and the
column so since we are
since we are referencing this class here
we can go ahead and specify that we are
referencing user then we can specify
that this
user id will be matched with a specific
column on this
class so that's going to be the id the
id column
so on here you can do a dot id now the
next thing you're going to do is on the
user class
we're also going to define a
relationship with the bookmarks
so over here i'm going to have a
bookmarks
so for the bookmarks we're going to set
that onto db
with relationship so for the
relationship then we can specify
the class that we are creating this
relationship with
that's going to be the bookmark one and
then over here i'm going to say a
keyword called backref
then i'm going to set that one to user
now this keyword here
is just another way for defining a
reverse relationship
so this way we don't have to come on
here and we specify that there is
another relationship
and this is going to take care of us
being able to do
bookmarks bookmark producer
so just the same way we'll be able to do
user.bookmarks we can
this allows us to now also be able to do
bookmark dots
then they what we specify here
so now that we have that out of the way
let's also have a reaper method
for our bookmark so we have a
a reaper then we just have bookmark
you can just return anything here let's
just get the id
or the url that looks better so one
thing we're going to need here is we're
going to need a way
of creating a short url from a url that
is given to us
now whenever an object is being created
or when our class is being instantiated
the constructor gets called so over here
we're going to overwrite
data in it now we're going to be taking
in self and all the other
keyword arguments now over here we are
going to find a way of assigning
a short url when this object is being
created so here
we're going to do self dot strategy
so i'm gonna have a function called
generate show to you a rare
it could even be the redshirt characters
because in essence we're actually
getting the character
so i'm gonna change this one to shoot
characters so let's create this
now since we are in a class we're going
to have to call it using self
so we'll have def generate short
characters
so text itself just so it can access all
these other members
so thinking about how we are going to do
it we are going to find a way of getting
all the possible
characters and picking random three from
those possible characters
and the ones we we pick we need to make
sure that we have not picked them
before so first off we need to get our
numbers from zero to nine
now we can get numbers by using the
string class
so over here let me put string so import
string
so if i go down here now to get numbers
from zero to
nine with characters equals string
then on the screen we call digits this
is gonna give us
zero one two up to nine and then what i
want us to do is also add all our
alphabet
alphabet letters from a to z so we can
get all the alphabet letters by using
the
by calling string dot sk
letters on this very notes i'm going to
introduce you to the first share so with
flask you can just run flask share
and that's gonna take you to like a
python share
but in here you can go ahead and you
import everything in your app you
interact with it as if
as if it's a real first cap being run
so that's why so i'm going to import
string just so it's how that works
so if we do string dot digits
you see we get 0 to 9 and now if we do
string
dots escalators so just just
to ascertains you can see we have a to z
and then we have the version where the
the letters are
and then we have the versions where the
letters are kissed now for us to pick
random derivatives from this
what we're gonna do is here we're gonna
import random so
and then we're gonna be using choice
from random to pick them
so down here i'm going to have pictures
we'll set that one to random
but choices so if we do random those
choices then we can give it
like where we want to pick from so we
want to pick from characters
and then we can pass another key for the
weights so this
so the key specifies how many we want to
pick from there
now we can do we want we can say we want
to pick three
so if i did this if i came here and put
it random so if i put random down here
and then i did random
road choices and then pass the
let's just pass the the letters asking
the escalators so i'm gonna pass them in
there
so let's pass k equals 3
so when we do that you notice that it
gives us a new list
now what we want is to turn this now
what we want is a way to turn this into
a string and
not a list so we can do that by using
change so we joined by
an empty string so we can do empty
string dot chain
and then we can go ahead and change this
so i'm going to copy all this
and paste it in there and run this
and now you can start to get our strings
in a string format
so that's what we're going to do here so
over here i'm going to do this script
chain
then we're going to join this so that's
going to give us our three strings
now something we're going to need to do
this should be big
now something you're going to need to do
is make sure that this don't exist
already in advance otherwise
otherwise our link tracking may not work
well over here we're going to have a
link that exists so we're going to do
link but we're going to set this one to
self and then we can access query when
we're on a model
so self dot query and then we can do
filter
by so here we want to filter by this
short url
so before we insert the structure we
want to make sure it's not there
so you can filter by short url equals
short because depict characters
then we want to call first on it it's
going to return for us a varied bookmark
or it's going to return none if none
exists so here you can check if we have
the link so if you have the link then we
want to try getting another one
then otherwise our strategy will equal
to the characters we just picked
so over here we can have an else and
then we just return
this so if it exists we are going to try
to find it again
and again until we get one that doesn't
exist
so over here we can just record the same
function function so we're going to do
so without
generation cases and then it's going to
retry
until it gets a unique one so now that
we are done with this
we are pretty much done so one thing we
are going to need to do
is specify a uri that we can give to
simple argument so it can connect to it
so i'm going to go here in our first
game now i'm going to the first game
because working with
those things it brings some issues on
windows so i want to keep things
in here but be sure to change your
database uri to a file you don't want it
to
to get so over here i'm going to have
export
sql and then i'm going to set that one
to a local sqlite path
and then we will put three slashes and
then we are going to have one called
bookmarks
dot db so once we define this then we
can grow in our app so we're gonna go to
uh
create then we're gonna go to a factory
function
so here where we define the app config
from then we can go ahead and specify
the sql archime url then we're gonna set
that one to
os put environment
go to get this so we named ours as a
as sql archimede db uri that's the one i
want to make sure we have here
so one thing i've noticed is we named
our columns using a small letter
now this should be a capsulate another
small letter so let's go ahead and fix
that before we go any further
so i'm going to select every every
occurrence
then i'm going to make sure that this is
the captus and now the last thing we're
going to need to do is register our dp
with our app
so we are going to import our db so so
from src
to database import db
so down here before we register our
programs then we can go ahead and run db
dot db dot app
equals app and then we want to do
db dot init up
then we specify our app just like this
and now once we're done with this
we can go ahead and set up our tables or
set up our database to start working or
accepting
connections here i'm going to go back to
the first shell so the first
shell and in here we can import our db
so we can do
from src database
import dp so with db
now we can call create all
and when we do that and we do a db again
you can see that now
this has created a path inside our
rest api source folder and it's called
bookmarks.tv
so this is how you create the box by
running create all
now if you ever wanted to destroy all
your tables you can just do that by
doing
db dots
drop or like this but we want to create
them so we will run
create all and make sure that things are
good and now when we come back to our
folder structure you can see that over
here we have a bookmarks.tp
so if you have a sqlite explorer you can
go ahead and you see our columns
but now this is where it is and this is
where it's going to live for now
so that is going to do it for this video
so in the next video you're gonna start
working with like registering the user
and also to login users and all that fun
stuff so
thanks guys for watching if this one
helped you out give it a thumbs up don't
forget to subscribe
i'll talk to you in the next video
hey guys welcome back so in this one
we're going to be talking about http
status codes
and how we can set them up on our
application now first to understand what
http server scores are
it's basically a standard way for
servers to communicate
to the client of what happened on the
server
now as much as we can be able to on the
server let's
send back a message like yeah something
was created on the server or hey
something was deleted that is something
that
we humans can understand but grants and
servers communicate to each other
by looking at which data spots the
server returned
so for example here i'm on instagram.com
and i've filtered all my requests to
only return the xhr requests
so you can see here that the status for
all these requests was 200 meaning that
things were fine
now we need to be able to tell which one
to send back to the client
depending on what exactly happened so
when i sign out you can see that now we
have some other status quotes here
and this was of course issued on the
facebook server
back to this screen so this client can
know what to do
so this is the twitter login page notice
that when i enter a username that
like doesn't exist and i click next they
go ahead and send us
a 400. now understanding this status
calls proper is very
is very important just so we can
understand how what clients would expect
and how they they would interpret these
errors so you see that it's in red
and there's a reason for that it's not
because the developer quoted it it's
because the
chrome client is built to interpret that
as an error so what i'm going to do is
in our application so i'm going to go
here in our app
so just go to constants so in constant
remember we set up this file here
and then i'm going to bring in these
status codes here so you can see that
they all start with http and then they
code now these codes are the ones that
the browser will interpret and that's
and they are the ones that we are
setting to the values here
so you know applications we are going to
be using the status quotes this as a
constant and then it's going to be
picking this by default
so these are the most common ones now
you can differentiate when to use this
we're going to send this
by looking at what you're doing now on a
server
if something we want to send back to the
clients is something informational so
you
want to use some of the status quo that
start with one if we want to notify that
something was successful
we want to use ones that start with two
for example here you can see that
if it's just a mere okay we just send
the 200
if something was saved we use a 201
so if there's nothing to send back to
the client we send it to all form
and the client will perceive this as
successes
so if you take a look at uh the
redirects one the ones that start with
the 300 so 300
so 301 302 and the like those ones will
represent that there was a redirect on
the server it might
be permanent so be sure to take a look
at the difference
with the naming here so we also have the
client so if the user
if there's like a validation error on
the client we would be using like a 400
if there's an issue on the server let's
say a server can't handle the alert
we would be extending back at 500. so
that's our introduction to status codes
now in the next one you're going to
start registering the user
so when a user has errors we will come
in here and we check if we want to send
them like pad request
or if the user if we're able to save the
user on the server that one means that
if source was created then we're going
to use it like this
so by the end of the series we'll
possibly have worked with most of these
so so that's gonna do it for now if this
one helped you be sure to give it a
thumbs up don't forget to subscribe
and i'll talk to you in the next video
hey guys welcome back so last time i'm
able to
set up our status quotes and now we know
where we're going to be picking the
status quotes
so in this one you're going to go ahead
and start registering a user if we go to
oauth.pi you see we have an endpoint to
handle that
hundred there is the user registration
so if we went to
our postman admit and so if we went to
our postman and then created a new
request
and then and then created a new request
so our new request will be a post
request
since our endpoint accepts a post and we
are going to be going to slash
api search v1
register and did a post request
we are not sending anything but we get
user created here but this is not real
this is not working with the db this is
not working uh
this is not checking the user's data so
what you're going to be doing
is sending things like username email
passwords
so when we get this in our in our
handler
we should be able to like create a an
encrypted password
we should be able to validate that the
email is valid that the email is not
taken
the username is is alphanumeric and all
that fun stuff so let's start here
now i'm going to close down this because
my screen is actually small
so we're going to start by importing a
few things to get
from what is this one called
so from work suck we do
the security import
check password hash generate password
hash
so generate password and take password
hash are going to be used to
encrypt the user's password when we save
it in a tv
just so people don't actually go in the
db and they see people's login
credentials
so now over here what we can do is we
can try to get
the data that the user is sending so we
need the username the email
and also the password so to get what is
sent in a post request we need to also
import requests from
flask so with with the request
we should be able to do json
and then here we can define the key that
we expect username to be sent in
so expect this one to come in in a
username
let's do the same thing for the email
and then the password so email
and then the password so we're going to
do some simple variations so we're going
to check if the length of the password
is less than six so it can be if it's
less than six
then it won't send back an error so send
back an error you're going to be using
the sonify
yes so let's get this sonified here so
send back json you're going to be using
just one file so let's get that so here
we can just return
the sonify and we can just say
password use to short
okay now like we said we always want to
send back a meaningful status code
now over here now this will be
an area that's can be solved by the user
so we can send
a bad request here so you can just do
http
400 requests and that's going to import
our status quote right here
now that we have this check we can do a
simple check for the username
and also for the for the username and
also for the password
so for the username we're going to check
that this app for numeric
have a simple check make sure that we
actually entering a varied name
so we just check the link so just check
the link of the username
and let's have all our names be
these three characters and above so we
can just have username
is too short and be sure to change these
messages if you dim
it if you have some data messages to use
so let's
so now let's check that the username is
alphanumeric
now we can check if a string is is
alphanumeric by calling
by calling dot is rna so we're going to
check if it's
rna so we're going to check if it's not
alphanumeric also you're going to check
if it has a space in there so we can
just do if
space in a username then you can tell
them username should be
alphanumeric also you can just tell them
also no spaces
and also now that you've validated the
username and also the password
let's go let's go let's also go ahead
and predict that the email they are
giving us is a varied email now we could
violate this using a regex
but i'm just going to save ourselves
time by installing a package called by
datas
so i'm going to do quick install
validators so as that installs then we
can come over here and report
quality data so if you have our data
then we can check that
we can use that validate image and say
if not validators
email then we can pass the email that we
want to validate so if the user's email
is not valid then we want to send them a
json response
and tell them that hey your email is not
valid so we're also going to check that
if the
image is valid it is not it doesn't
exist already in our db
since our restriction is precise that
our image should be unique so we can
check that by doing if
so we're going to import our model
actually because we're going to need to
query the db
so from source dots database
imports user all right so here we can
just create a query by doing
this user dot objects then we want to do
filter by so
filter by then one check if the email
equals this email then let's just do
that first
then we want to check if it's not none
so if it's not
none if it's not none that means that we
have one
at this one record that matches then we
can tell that we can tell the user that
this one already exists
so we can return json then we say email
is taken
we are going to do the same check for
the usernames because the username
should also be unique
now take note of the status code that we
can use here so if you go back to our
status codes
right here in the 400 level notice that
we also have one for the
for the conflict this means that a
similar resource already exists on our
server
so what you can do here is we can use
that instead
so we can just do http
409.
okay so let's do the same check for the
username i'm gonna come back over here
and just do the same check for the
design so we're gonna check for username
and if it exists we tell them hey it's
taken and we send them a conflict
response
so now that we have these checks in
place now we can go ahead and hash the
user's password
so we can have pwd hash
so this is going to be generate password
hash and then we just pass the password
we want to hash
so the one you're going to have of
course is the user's password so let's
pass password in there
now once we have the password hash then
we can try to save this
new user to our db so we can just have
we can say user equals
because user so when we instantiate it
we need to pass it
uh we need to pass it the values that
are going to save in our columns
so username is going to be the username
the password is going to be the host
version of the user's password
so pwd hash
then the email is going to be the user
schema so once you instantiate our class
then we want to add it to the db
so here let's import user understanding
for db
so down here then we can say db
good session good add and we want to add
user
also want to do db with session want to
call commit
just so our changes can be saved now
once we update our now once we update
our db then we can tell
the client so now we can take back the
clients that
we were able to save this user on our db
and maybe they can go ahead and login
so we can just return what you're going
to return to sonify
and in here we can just have like a
single message
so message so for the message you can
say user
created now we can also go ahead and
send back the user
so user will send back the username the
username is going to be the username
they gave us
also they send back the email and the
reason why we're sending back this
extra information is the clients might
need to maybe welcome the user by saying
welcome thanks for creating an account
so they can use this
this username that we confirmed on our
server just send a message like that
then the last thing we're going to need
to send here is the status code
and whenever we create the resource on
our server we want to send backup 201
so we can do http 201 created
so now if we run if we run back our
server so i'm going to do first run
notice how we get this warning here
about simple argument now i'm going to
suppress it here just like they are
suggesting
i'm going to suppress it by going to
our init and here where we configure our
app
we can pass the zipper to my uri
and also this so i'm gonna set that one
to not
i'm gonna set that to false just so it
stops yelling to us
so once you save that you can see that
it resets no warnings and now if you go
back to our postman
so i'm going to go to postman this is
the request endpoint
then i'm going to select json here now
when we select json then we can be able
to send our keys and values so we can
just do that
like username
so for the username i'm just gonna say
username
reset the password
so the password can be password then
let's also add an email so you can do
email
let's have email at app.com
and now if we made this request so if i
click send
oh notice that we get an error and the
reason why we're getting this error is
because we are doing
with objects so this should be dot
querying
so let's change that one to slash to
build query
so now if we try to do the same request
notice that we get our user created and
we get a 201
so so now if we try to save
to create the same user you see we get
the error image is taken
so if we change the email i'm going to
add another pin and try again
you see that we match the username is
taken so i'm going to change the
username but i'm going to make the
password short
so if we try to do this we said the
password is too short and we can't use
that
so let's just make sure our password is
good
so for the username i'm going to leave
some spaces and also add some
information marks
we try this is that the validation for
the username is also working good
now if we do
now if we leave only a space let's do
that you can say that it is still being
handled properly
so if you run this you can see that we
get another user being created
and yeah so that's gonna do it for now
that is how we register a user now in
the next one we're gonna be talking
about how to
use gear directory identification how
that whole token of the application
thing
works and uh how to set it up with our
app
and how to log in a user so thanks guys
for watching if you enjoyed the video
give it a thumbs up
don't forget to subscribe i'll talk to
you in the next one
in this one we are going to go ahead and
set up jwt authentication
and also log in our users and give them
access tokens and refresh tokens
now if you are new to token
authentication so when you're making a
risk api like we're doing here
it is intended to be consumed by
different types of clients
so we can have an app that may be the
chrome extension an android app an ios
app
a front-end app like a react app so
authenticating across all those
different types of clients
calls for a solution that is not session
based because by default
we can use sessions to track which user
is logged in when they log out
and what they can access but that would
not work if we are going to like have a
mobile app
so the approach that we take in that
scenario is to implement
token based authentication where
whenever a user has a correct login
on our server we give them a token that
they can use to make calls
so that we can identify which user it is
depending on the token that is being
sent to us
now previously the way we would
implement this is with great like
a token table where we have like a user
and their tokens
but most recently we have a new standard
called jw team
now jwt allows us to create these tokens
without having to maintain a database
table
for these tokens and their users now
generality does this by using encryption
techniques
that based on a secret key so with a
secret key we can be able to
encode user's information into a token
and then when that token comes back we
can decrypt it using a separate key
and then we can tell which user it is
without having to make a call to a
database
so to implement this we have different
libraries that implement this we can go
ahead and
implement it from scratch using the the
pi data regime module
which is an official way to interact
with generity from python
but that will call for a lot of work
so that means we have to to do almost
everything ourselves
so some packages have been developed in
response to making this process really
easy
and the one we are going to be using is
frustrating extended
so this allows us to almost do all the
use cases we might have like
working with refresh tokens revoking
tokens so we're going to be installing
this so i'm going to go to the
installation
and we are going to need to install we
are going to need to do prep install
first generation extended so i'm going
to go to our terminal
then i will stop the server and run
quick install this
so to set it up you're going to go to
our app because we're going to set it up
with our app
then we're going to go to generality
extended then we want to import
data retain manager so once we have the
data retain manager then the next thing
you're going to need to do
is come and set it up with our app so
over here we can just do jdwt manager
and then set it up with our app such
that when we return it so that when we
return it
it knows that data ready was configured
now
one thing i mentioned before was that
generality authentication base is on a
secret key to encrypt and decrypt
tokens so we're going to need a way to
tell it about our secret key i'm going
to go to our flask m file
so flask n so here you're going to have
export generated separate key so i'm
going to set it to secretly
and like i said and like i said for
for very crucial information like this
we want to put them in a dot
in but right now i'm putting them here
just so people on windows don't get the
same issues
but if you can put them in dot m be sure
to source in
the source dot mv in your terminal just
so it gets updated and picks it up
but for now this should work fine so
once we have this
in our init we also need to pass it so
out
so down here we can pass through the
retailer jada is accurately
and we'll set it to 4s varan
gets so we'll be getting generity
separately
like this so the value here can be
really anything
but you want to make sure it is is very
secured
so make sure it doesn't really leak to
version control and it should only be
known to your server
so once we have that now we can go ahead
and start to work with uh
logging in a user i'm going to go down
here and we
we will create another route to log in a
user so we're gonna
have update post so upload post will
detect when user is going to search
login
so when a user goes to slash login we're
going to try the function
under that so we'll have login but log
in a user we're going to first get the
email and
the password that they are sending us
now we can do that by doing email
it's going to be request json email
let's also get their password
so we can just do password so one thing
i want to do here is instead of us doing
this instead of us using this syntax
here we're just going to use a
get so gate allows us to specify a
fallback value
if the user didn't need to actually send
the email but in our case
since these are the keys so these are
the keys that our front end should send
and this user is handled by developers
we can still relay that this iphone is
going to be there
so here let's make sure so here let's
make sure we have a default variable
just so application doesn't crash so the
first thing we're going to check is if
the user with this image exists in our
tv
so we're going to have user equals user
dot query you know want to filter by
email
then we want to do email equals email
they don't want to be put first
so we can check if we have this user now
we can check their their password so we
can just have like this bus correct
so for the password remember our
password remember the password we have
in adb
is encrypted but the one the user is
giving us is
is in plain text so for us to be able to
match those two
we are going to use this function here
we imported called check password hash
so down here we can just do check
password hash
so check bus check password hash takes
in the hash so the hash is going to be
the user's password from tv so that is
going to be user
with password because in adb it is a
hash and we are going to be checking it
again is the password which is
now in this case is this password that
the user is keeping now
so now we can check if this password is
correct so we can do if
his password correct then that means
that the user's authentication that the
user's login was good
so we can create for them an access
token and also a refresh token
let me go here and import some utilities
so i'm going to do from first data read
extended import create access token
and also create refresh token now i'm
going to be talking
about the details of this as we go but
right now what we want to do is uh
here once the password is correct you
can just have like refresh
ecos create refresh token
so refresh token takes in an identity so
once you say identity you can think of
the identity as the user
so in this case we can just pass like
the user id so you can just press
user.id
let's also create the access token
so access the identity can still be the
user id
so once we have this so once we have
this we can now tell the client that hey
everything's going to work on that
server
the user is who he claims to be and you
can go ahead and maybe redirect them to
the homepage and show them their
stuff so here we can just return to
sonify
so in here we're going to be sending
back the user but
but now we're also going to be sending
the tokens in the user object
so you can pass the refresh and also the
access this also sent the
name so username
this is gonna be user.username
and also the email which is going to be
user.email
or rate so now
if so now if we didn't match any user
with this email
or if the password was wrong then we are
just going to be returning
wrong credentials so over here we will
be returning
jsonify wrong credentials i'm just going
to have an
error here and then we can say run
credentials
and then for the status code we're just
going to say and authorize it so we
didn't authorize the user
it's going to be 401 it's going to be
http
401 and authorized
okay so once we have this now we can go
ahead and test it out
if we did things correctly possibly
things should be working so let's run
first run again
so the server is back so we have an
issue here
uh oh we used updates this should be
okay let's rerun back the server
so we are back now if you go back to
postman
which is our testing client i'm going to
keep this one here but i'm going to
create another request
so this time we're going to be going to
slash login
and if we try to do the git request you
said this is not being handled
but we want to make a post request we
want to make sure that we are sending
json
so i'm going to select json on here and
then
this here we want an email and then a
password so i'm gonna use
email at app.com
then for the password i'm gonna use a
password here
so if i try to send this notice that we
get wrong credentials but if we use this
user we created here
so i'm going to use this user anymore
i'm going to use this email here
that we have and also the password so
for the email it's going to be this the
password
so for the email it's going to be this
the password is going to click password
because that's what it is even
here so now if we try to login
we try to login to send and yeah we have
our tokens and we can go ahead and
authenticate the user and give and with
these tokens they can be able to access
any other part of our application
that is that needs them to be logged in
so
if i come here where we are sending
these tokens so it actually derived the
status code here that's good we already
specify our status quo
just so it doesn't mess it up at any
time
so yeah that's how we're just a user
that's how we give them a refresh token
and an access token
so in the next video we are going to be
talking more about refresh tokens and
that's how to refresh access tokens
so thanks guys for watching if this one
helped you out give it a thumbs up
don't forget to subscribe i'll talk to
you next time
in this one we're going to be taking a
look at how we can protect specific
endpoints
to limit them to only people who have
tokens for example you see we have this
slash me endpoint and in this slashing
endpoint we should be able to send back
the current logged in user's information
depending on the token that they use
by the one thing i notice upfront is
create access token might not be
something we use
down here so yeah this should have been
great access token
so just a mistake i just saw so let's
continue
so from first data already extended we
also have a decorator called
jwt required so you're going to import
generality required and whenever you
want an endpoint to require
a user first authenticate so we're going
to do a database required
and then that's going to make sure that
and then that's going to make sure that
if a user tries to
come here we are going to tell them hey
you're not you're not using a token so
please first get it talking
for example now if i went to the browser
and went ahead to slash
to slash api v1 me
notice how we get missing authorization
header so without this a user would
still be able to access the route so if
i come back
you can set it works but with this the
user will have first authenticate
so let me bring up my post one again and
for us to authenticate i'm going to
create another request
let's say like here and this one of
course is going to be
going to me so to add a header if you go
to
our login so here in our login
if we try to make the same request get
the access token
this is what we want to send on all the
requests that need authentication
so here i can come to oath and go to
bear a token so this the type we use
here is vr token and i'll show you more
in the documentation
and now if we make this request notice
that now we're able to access
the notice that now we are able to
access the route so if this token is
malformed or it has been tampered with
you should be able to see that the token
was not correct
so yeah so for us to be able to get the
real user
so inside here we can use something
called get the awful identity
we are going to put something called get
data really identity so down here
i'm going to import pdb here so pdb is
the python debugger it enables us to
pause a program and then we can expect
some variables and functions
so i'm going to pause that and then when
i come here and try to make the same
request
you said it gets paused here but when
you do get it ready identity and call it
it gives us the user id that was encoded
using that token
so we could go over here and do let's
say user
equals get every identity so that's
going to give us the
that's going to give us the user id so
in fact i'm just gonna put it user again
then we can go ahead and now query our
tv get which user this one is so we can
do
user user dot query
we want to say filter by one filter by
id
and then we're going to filter where the
id is the user id
and then let's call first because that
should give us only one
so we can set this one to the user now
we can just return
now we can just return this you can just
have like the username
which should be user but username
and also the email which should be user
email uh yeah that's it
if you go back to postman and make the
same get request notice that to get the
user sent back to us
so let's make sure we are sending the
status code
and things should be good so that's how
you get the current login user
if you had like a profile model that had
like more information you would get them
here
and also something i should mention
probably is the application welcome with
here is pretty simple
but if you had like large amount of data
you literally might not want to be doing
like user.name you might just want to
release user
at glass without having to get the
attributes so you would be doing that by
looking at something like marshmallow or
other ways or creating
specific serialization classes that can
do that work for you
but for now this should be okay we
should be able to still do fine
so thanks guys for watching next in the
next one we are going to be
looking at how to create refresh tokens
if if this video was helpful give it a
thumbs up
don't forget subscribe i'll talk to you
in the next one
hey guys welcome back so in this one
we're going to go ahead and see how to
refresh your token
okay so whenever we log in a user we
give them two tokens the access and the
refresh
now the access we've already seen how it
can be used we can use it to access
protected endpoints like this
slash main since the access token grants
access to
resources on our server we always want
to make it short-lived
say that in any case that someone gets
access to it they still wouldn't use it
to access resources on our server
for a long time so just something to
mention here
you see how we have all these
configurations here now the one we set
was only the secret key but if you
wanted to set
anything else like any other any other
config to the
to the module be sure to check one of
these
so for example you can see access tokens
by default will
will take 15 minutes to expire but we
could change that if we wanted to
and the recommendation is to always make
it as less than this as possible
and then you can see that the refresh
tokens can be exactly so you can always
use this to refresh the
refresh token to refresh the access
tokens
so to now create an endpoint to refresh
the access tokens i'm going to go to
our code so over here
we will have another endpoint it's going
to be slash both
slash auth then dot we can have it dot a
post so i'm going to have a post here
now here we want to go to when a user
goes to slash token slash refresh
so let's create a function to handle
that
so refresh token user token one thing
here we want
the user to only access this endpoint by
giving us a refresh token
now for us to enforce that what they
give us here is a refresh token
we're also going to use a jwt required
this decorator here
on this very view but the difference
here is here we're going
to we are going to expect them to give
us a refresh
we want to x we are going to expect them
to give us a refresh token
so we're going to pass refresh equals
true so to handle this what we want is
to first get who the user is so we can
do identity
then when you do get get the identity
thing should give us the user id so now
we can create a new access token
so we can just say access token should
we create access token
and in this case we pass the identity
which should be our identity
and now that we have a new access token
then we can return to the user
you can just say return to sonify then
let's have the access token for the user
then it's going to be the new one we
just generated for them and i will send
back at 200 so http
100 okay if we come back to our postman
so if we do a post remember we need to
send the refresh token
so you can see that it goes right to
validate that we are not sending it
so in uh in oath you can choose we want
to use bearer token
and we can if we try to use this notice
that it fails this one is expired
so we need to be using a refresh token
that is valid so i'm going to log in
here
and that's going to give us a new
refresh token and now we can use this
under this endpoint we can go ahead and
use that and now when we click
send you can see we get a new access
token
and this new access token is associated
with the very same user
who logged in here so that is how we
refresh the tokens
so if you wanted to use a different
method for this it's just up to you you
can just create it
doesn't really matter since we are not
even posting anything
so that's how we refresh the user's
token so i'm going to be posting the
video here
if it helped you out give it a thumbs up
and forget to subscribe the next
video we are going to start working with
the bookmarks creating bookmarks
and retrieving bookmarks and all that
fun stuff
so one thing i want to show you guys is
another one that you can define an
endpoint
so you see how we've been doing
bookmarks.get bookmarks with posts
if we wanted to have an endpoint that
had those two http methods
we basically would do bookmarks.get all
the posts
like that and then we'll have a function
that can handle
any of these but you will see a lot of
source code that will be that will be
defined differently
like this so you will see bookmarks load
route somewhere
this was the standard way to to define a
route in the previous versions of flask
if we wanted to define an endpoint that
accepts both a get and a post method
we would be doing it like this so
as the second argument we can specify
methods
and that can be a list where we can
specify the methods that
this route will handle so in this case
we want to use the same endpoints to
post or create a link or a bookmark
also we're going to use one to get all
of them now here we can have a function
to handle that
bookmarks so in here if we wanted to
check which request method the user used
we can go here and import request from
frosk2
so down then we can check the request
method by checking if request
loads method then you can check if it's
get or post
so if it's supposed that means that the
user is going to be trying to create a
new link
on the server so what you can do is we
can now get the body
so body we can set that one to request
dots get json whether you can do json we
can do
get json and then with this you can do
it.get
and we we want to get the body so let's
also have a
a fallback just so because the body can
be nullable
so let's also get the url so the url of
course we're going to get it as url
we need to check if this url is valid
because that's a very crucial part of
our application
for everything to work the redirects the
url has has to be valid
so let's import validators so import
validators
now when we have validators we can check
if the url is valid so let's check if
notify data
dot url and let's pass our url
so if it's not a valid url then we want
to return an error so we can return
and then for the value we can say enter
a valid url like this
so let's go ahead and also send the
status code so this one is going to be
400. if the url is valid we're going to
check that this doesn't exist
in the database again because we don't
have repeated repeated urls
so we can just do a simple check so you
can do if so let's import bookmark
so from src dot
bookmarks bookmark so now
over here we can check if bookmark got
query
then we want to run filter by so we'll
filter by url
equals url so if this exists so let's do
first
so if this exists then once the user
that this already exists
so we can just come over here and we
return
a url already exists
and this is going to be a conflict so we
can do http
409
and uh yeah that's how we handle that so
if the url is valid and it doesn't exist
then we need to go ahead and we create
a new bookmark and save it to our
database so here i'm gonna do bookmark
so bookmark is gonna be bookmark
so instantiate our model class and then
we give it all the properties
so we need to set the url it's gonna be
our url
then we need to set the body it's going
to be our body
then the next thing we're going to need
to set is the user id
so for the user id this is going to be
the current login user
so user id is going to be the current
open user
so i'm going to do current user so to
get the current user
you know we have something called
getability identity
just go ahead and put that from uh from
first
generation extended so get generity
identity so to get the current user i'm
going to define here we're going to get
there is identity and that gives us the
id
and as we are still here let's go let's
go ahead and we protect this endpoint
so we make it accessible to any users
that are logged in so here we can put jw
to required
all right and that should go ahead and
and we need to
import it which is uh
there so here we have the current user
as the id now what we want is we want to
import the db
so input bookmark let's also get dp
but we need to commit our
changes so db session
dot add bookmark
so let's also do db session commit
just so changes can be persisted okay so
after we save to the db then we can
return to the user
and this time we want to
just sonify
and we want to be sending the newly
created object
so since our properties are not really
so many we can now send back the id
so whenever we create so whenever we
create we get an id
associated with this bookmark so we can
just do that
from document to tidy from bookmark to
tidying
then let's also go ahead and send back
the url then the short url
so the url you can just use bookmark
here
then the short url that should be like
the shortcode
so short here this is going to be
bookmark
on the model we called it short url so
we can do that
then the next thing we're gonna need to
get is the
the number of visits so for the visits
obviously we expect them to be zero
because
by default we set it to be zero but
let's get that one then let's also get
the
body bookmark dot body
let's get created that created that
let's get updated that
so updated that
like this our status code
this is this is a creation we can send a
201 to http
201 created now before we test it out i
want to
create the one to get all so
down here remember our route can handle
two
http methods now since we want to handle
the gate or
so you can have an else and for a news
and if it's not a post request you're
going to be sending back all the
bookmarks
that this user had created so to get all
the bookmarks created by this user
we are going to first make a query for
it so we're going to do bookmarks
it's going to be bookmark or query
with filter by we're going to write it
by the current logged in user so you can
use that underscore id it's going to be
equal to current user
so that's going to give us a bunch of
bookmark options
now when we have uh when we have
bookmark options
we need a way to say your eyes those
python objects into
some data content of our network by
default we can't really send the
bookmarks
so what we're going gonna do is here
we're gonna we're gonna create our own
python list and then for each of the
bookmarks we're gonna be adding them to
our
data then we're gonna be returning that
so here i'm gonna do
a for item
in bookmarks so for each of those we're
going to be adding it to the
data list so we're going to do
data.append
so we're going to be adding appending a
new object and it's going to look like
this
so instead of using book so instead of
using item we can use bookmark
and bookmarks and for each of these
we're going to be adding them to our
our data list and then that's what we
want to return because that is a python
list and we can resign it using jsonify
so you can do return personify you can
have a key as data
and then the value as data and then the
status code should be
the 200. so you can do http
200 okay so once we have this
everything is up and running we can test
it out
and later i'm going to be showing you
how to use destination like to paginate
just so we don't get
everything at once so now that we have
this we can go back to our postman
so inside postman i'm going to log in
here just so we have a new
and the reason why we are getting this
here is you see when we come
to how we defined our function we go we
called it bookmarks
and this function is conflicting with
the name that we give to our blueprints
so what we want is we want to change
this to
to something else i'm going to call it
handle bookmarks
and then we also need to change a
generality required we need to
instantiate it like this
so once we do that and we'll try to log
in here so when i log in you can set now
we get our access token
so i'm going to copy the access token
and i'm going to get another
url so for this url for this area we are
going to go to d1
bookmarks so if we try to make a request
to this it's going to say we need to
authenticate
so i'm going to go to my auth and then
choose jwt
choose bearer then use my token here so
when i send a request
let's actually get an empty list sent
back to the user but we get a 200.
now if you want to post to this so if
you want to create one we're going to go
to our body
so i'm going to select row here and then
i will choose json
so we need to send a url so for the url
so we need to send a url so for the url
i'm going to have a google url in there
so let's have so just have it google.com
so it's also have a button so for the
body it should be
double quotes for it to be very json
let's say
my site so let me change it slash images
just so i can show you something
so if we try to post this you'll notice
that we get an error
and the error we get the sky is because
we are not putting the slash
so we need to put a slash just so it can
be handled properly by our route
so if we put a slash there and submit
you can see that we get our url being
saved
and also we get a shortcut being
assigned to this
and later we're going to be seeing how
we can work with this shortcut to be
able to track how many visits we did to
this
url so now if we go back if we do a gate
again so if you do get request
you can see that now in our responses we
get
our urls being sent back to us if we
made the third one let's say this one
now goes to
bing dot com so let's post
this my bing sites
is sent because it gets created now if
we do a get request
you can see that now we get three items
being sent
to us so that's how we do a basic create
and read on our bookmarks table
so if the video helped you out be sure
to give it a thumbs up don't forget
subscribe
i'll talk to you in the next one
so now we are able to list all our
bookmarks whenever we make a get request
to slash bookmarks
so in this one we are going to go ahead
and implement pagination
on this list as being able to send a
thousand records at once over a network
will be costly in terms of the user's
data
so what we want is to be able to allow
the front end to request a specific
number of items and also on a specific
page so what we're going to do here
is uh just maximize this so right now
the way we are acquiring this is we are
doing
query by the current login user but also
what we want is we want to be able to
paginate now with reboot.net we are
going to need two things
one will be the page we want to get
records from another one will be there
would be the package count i'm going to
first get the page of the
of the records where we are trying to
get from the front end
so we can get that one from uggs so
we're gonna do request
dot ads then we want to do get page so
by default our page is going to be one
and then we are going to type it to an
int so we're gonna be type equals and
so if the user doesn't send the page who
just defaults to sending them
page one okay but if they send it then
that's gonna be the page we queried by
so now that we have the page let's also
get the per page
just so we know how to limit our query
so we can do part page it's gonna be
request
dot x then let's get per page so per
page the default is going to be 5
then let's also type it as an int so now
that we have this
on the query we made we can go and do
page in it so we can do betternet
so paginate takes in two things one will
be the page so you can do page because
it goes the page and also the per page
so per page we already have that
let's do a page so that's gonna keep
working the same but
now we also want to be telling the front
end that hey there are some other pages
that you might want to check out
so down here i'm going to have a
property called meta so i'm going to set
it to a dictionary now one of the things
that we're going to be sending back to
the front end
is the current page so we can just send
the page so to get the current page we
can get that from the bookmarks we can
do bookmarks
that's going to be page then the next
thing we're going to need to send is the
number of pages that
are there we can also send like the
total number of items
so that's going to give us like all of
them then something else that we might
work with is uh the previous number so
if you have on page 2 the previous
number would be 1.
so that is obvious to get even when
you're in the front end but let's go
ahead and send it for the user
so to get prev we preview number so get
the previous one we just do
preview so
for the next we can also send back the
next page
by doing next i'm going to call it next
page actually
also this can be privileged so we also
have some other properties like has next
or
has previous which i think we can also
send just so we can look at how they
how they work so as next so in the
bookmarks we have
has next we also have has prev
so has prev that's what we want to check
here
so let's go ahead and save this now now
that we have the meta we can go ahead
and when we send back our data
we can go ahead and send back the meta
so here we can send meta
so now if we go back to our postman and
we try to get this
you can see that our token has expired
so let's go ahead and refresh and create
a new and login again
in the in a real app you would have a
strategy to automatically refresh it
just so we don't ever get that token
expired message
so now let's go over here let's go over
here and change back the token to use a
varied one
and make a request you can start to get
this error that's pagination object is
not iterable
and there is no and the reason why we
are getting that error is whenever we
imagine it
so whenever we button it on our query we
get more things sent back to us
now the data itself or the bookmarks
themselves they are sent back to us
in an in a key called items
so it's and then these are the things so
these are the things like hasbro
pages page those ones are also in those
specific case
but the data is in bookmarks with items
so that's what we want to
so that's what we want to now loop
through so i'm going to come here and
now make the same request
and now you can see that we get data
being sent to us
so down here you can see that we have
the a new meta
property and it has all these details
for us
now i'm gonna go here and actually
create more just so we can test out the
pagination
so just allow me to quickly change this
and just have some more urls to work
with
okay so now we have more than more than
two pages so if you do a get request
again
you should be able to see that we get
only five cents back to us
and we can see that has next is strong
has previous is false
and we are still on page one but if we
wanted to request page two
so to request page two you can see here
in our code
we said that we can send the page so we
can send it as
as an argument so in postman
we can do a query and we send page
because they said 2
so when we say page equals 2 notice that
now we are
sent all the details that are on page 2
and you can see that now we have some
previous that we skipped
some previous items that we skipped so
if we requested paid three notice that
we have only
notice that we have only 11 items so
page three should only contain only one
item
if you go to page three you should be
able to see that
now you should be able to see that we
only have one item sent back to us
and if we wanted to adjust how many we
request we can just come and
add and put an ampersand then we save
per page
so by page let's say we want all of them
but now that means basically won't have
any
so if we do that you can see we get this
four or four
so if we request page one we should be
able to get all of them sent at once
so those are the basics of how to
paginate now thanks guys for watching if
you enjoyed the video give it a thumbs
up
don't forget to subscribe and i'll talk
to you in the next one
so now that we are done retrieving and
patinating our bookmarks
let's go ahead and create a page which
can retrieve a single
item so to create that page we're going
to keep in our
bookmarks blueprint so over here we're
going to have at
bookmarks
then we want to do good so to get one
we're going to be getting it by the id
so over here we can have hints
get the id this is going to be a dynamic
id part of the url
so over here is a function to handle
that
so let's say get bookmark
when we have specific variables that we
are passing through the requests
we want to also accept them in the
handle function
so inside here now we can use this id to
find that
item but first the first thing but first
we also need to make sure this endpoint
is protected
so to make it protected we're just going
to do generity required
here let's define the current user so
that's going to be getability identity
now we want to ensure that the user who
created this is the only one who can see
it
so we're going to make a query to a dp
so the db query is going to be
bookmark.query but filter by so we want
filter by user id
it's going to be the current user and
then we also we're going to try to find
this this bookmark by this id so we're
going to do id equals id
and since it's going to be one we want
to do first just so we get that very one
so if we don't get the bookmark so we
can do if not bookmark
[Applause]
so that would mean that it's the one
trying to request it is not that's very
user
it's not it's not the user who created
it so this didn't match
or they are giving us an id that we
actually don't have in adb
so if we don't have it so if not
bookmark
then we can tell them that hey not found
so we can return
jsonify then we can say
message and let's do item not found
so for this we can send back a 404 so we
have an http method for 404
it's not found so 404
not found that's the one we want to send
back but
otherwise if we have the bookmark then
we can go ahead and return it
so just like we did here we're going to
return something like this
so we will have written return the
sonify
so we'll be just modifying this
the id and all these other details so
then we send back at 200.
so http 200 okay just like this
so now if we go back here and try to get
on slash bookmarks slash one
notice that our token has expired so
let's go ahead and refresh it
or we get a new one so let me just get
this
then i'm gonna go here then in the earth
then i'm gonna change that now you can
set we get
that one but if we try to get one that
doesn't exist like this one
we get a note found and we get a 404
being sent
so that's how we retrieve one so in the
next section we are going to see how we
can
delete update delete or update
so thanks guys for watching if this
video helped you give it a thumbs up
don't forget to subscribe
i'll talk to you soon
so now let's go ahead and add ability to
edit
a bookmark that we've saved so we should
be able to change the details of the
body
or the url itself so to do that
it's actually going to look a lot like
the ad so we're going to have
a handler for that so on here we'll have
at bookmarks then we want to call dots
we use two common http methods
one is the boot another one is the
another one is the patch
so we want to target when a user is
going to
put on the height is making a put on the
id so we can also
handle the same thing for the patch so
we can just have
patch on there too so then we can handle
we can handle
edits bookmark so we also need to expect
the id to be sent we're also going to
need to first check if it exists
because we don't want to try to exchange
something that doesn't exist
let's make sure that the user is logged
in so we're just going to put a jwt
required
decorator so over here you can go ahead
and verify that the bookmark
exists already so if it exists then
we're gonna go ahead and we change it
so we're gonna we're going to get the
new the new body and the new url that
the user is sending to us
so if you go in our post you're going to
need to get these and also we're going
to validate the url
so i'm going to copy this very thing
so down here
we can now get the body that the user is
sending
and the url and then we'll predict that
the url
the new url is actually still still
valid
now once the url is valid then we can go
ahead and update it in the db
so since we've already found the
bookmark it's here to update it
we want to do bookmark dot url
we'll set it to the new url and then the
body
it's gonna be bookmark body
it's gonna be the new body
okay then after we do this then we want
to call db
with session dot commit
okay that's gonna make sure that our
database
syncs the change so
this is how we update so to test this
i'm gonna go to
our postman then i'm gonna get one
so when we get one now remember we need
to put to make a put so i'm gonna make a
put but i'm gonna change
so i'm gonna change the url from google
so i'm going to change it from google
to sites.google something like this
let me change the body to my google
site site so let's change this so now
so now if we do a put on this you notice
that we get and we get an
error that the function didn't return
properly that's because when we finished
committing
the session we didn't actually return a
response so we're going to be returning
a response
so just the same the same way we
returned when we created
so on creation we returned this and this
is the same thing we want to return
except that we want to return a new
except that now the
status will not be created but it will
be just it will just be okay
so we just return the sonify then this
is going to be http
okay
so if we try to change now again you can
set to get a new one
so you see the id is kept that it was
before
but the url is changed to a new one and
yeah so that's how we update if we made
a patch
so patch is usually used when we want to
update like
bits of these objects which i think
which should even be ideal for this kind
of thing
it will still work because our handler
handles both of them
just like this so yeah that's how we
that's how we update so in the next one
we're going to be seeing how to track
which links we've visited and the links
we have not visited
so thanks guys for watching if you
enjoyed it give it a thumbs up don't
forget to subscribe
i'll talk to you later
hey guys welcome back so let's go ahead
and see how we can delete
an item so by the end of the video we
should create an endpoint
we should take an id and then check if
the user who's trying to edit it is on
who created it
and then it's it deletes it from the db
so
to do that you're going to do something
that's similar to the gate so i'm
actually going to copy this over here
so down here i'm just going to duplicate
this
and now we are going to be doing a
delete request so we're going to do a
delete
and then we expect the user to give us
an id we want the user to use the
authentic
we want the user to be authenticated so
we just
have this decorator then we're going to
name rename this to
delete bookmark so we check who the user
is then we are going to first try to
check if the user is going to offer it
or who owns it so if they are not the
ones then we are going to tell them hey
we didn't find that
so otherwise we want to delete it so now
we can do it is using the tv so you can
do
db.session delete so we're going to be
deleting the bookmark
so we need to confirm that by doing
db.session
commit so
now that we finish deleting we need to
send back a we need to send back a
response
now for the delete we can send back a
message like hey we deleted something
but a lot of times you're going to see
that a lot of times this is going to be
implemented by sending a no content
status so here we can just return for
the content we just leave it empty
but then we send back a no content so we
can do http
204 no content like this so now
if we go here in our terminal and we'd
make a delete request so if we do a
delete
you can see that it was deleted and we
get a no content if we try to fetch it
again
you can see that it was not found and if
we make a
get request to all of them so now we
expect all of them to be
10 and not 20. all of them
down here we have 10 that means it was
deleted from the db
so thanks guys for watching if this one
helped you to give it a thumbs up don't
forget to subscribe
i'll talk to you later
last time also we can update one and
also we're able to view one
so in this one let's go ahead and we
start implementing link tracking
now the idea for link tracking is just
so we can just so we can track how many
times the user
who created this bookmark clicked on it
because the whole idea for the bookmarks
is to be able to check them out later
just so with this kind of feature
we can implement something like on the
front end to allow users to see which
links
they are least checked out what the ones
they have checked out more
so to be able to do that the logic we
are going to use is
notice how we have the short url so we
have this but
this but with this we know that we can
map it to the url so we are going to
have a route on our app that will
be accepting something like this so you
see here we have slash
5000 we are also going to have slash
something like this
so with this we can pick which so we
with this we can pick which url it is
and then we increment
so it's visits count so the way you're
going to do that not
notice that this is not under any any
any blueprint so we can as well put it
here in our app and we let it get
handled by our app so
down here we are going to have an app
then we want to do a get
so for this we want when a user goes to
the short url so i'm just going to play
this tutorial
this is going to be a placeholder for
whatever the user
enters there it could be something like
this it could be any other
any other of those three characters so
this have a function to handle that
so i'm going to call this one redirect
to uri and of course we need to accept
the short url in there
and what it's going to be doing is going
to be finding the bookmark and then it's
and then increasing its visits count so
let's import bookmarks on here so from
from database and put that let's also
input bookmark because we're going to
need to query the db
so on here we can just say bookmark it's
going to be
bookmark dot query
then we want to run filter by
so filter by so we'll filter by
so we'll filter by short area
and then we're going to check the one
that is go to this shotguard
now with this we can be able to call
first or forward for so in the previous
videos we saw we're doing first but here
you can do first of all for
whichever it comes in handy if you want
to there are an error so first or four
phone that's going to be able to afford
for error if we didn't find this
remember we need to handle every
direction we don't need to send back a
json like it wasn't found
so it's ideal to just throw an error
just so a user knows that
hey what i'm doing isn't working
so now that we have the bookmark we can
check if we have it so we just do if we
have the bookmark
then we can do bookmark.visits
so we're going to be increasing them so
we're going to be setting them to
bookmark go to visits
then we're going to add one on them so
once we do that then we need to
of course update by doing a session
commit
so db dot session
let's commit just like this now after we
update our database then we can go ahead
and
return and redirect so instead instead
of us returning the response here
we can return a redirect so from flask
we can also import redirect
so now here we can just return redirect
and we'll just redirect to the
url itself of this bookmark
so now we can just redirect to
bookmark.url
and yeah that should be able to work
this should be a placeholder
and not at the exact string so over here
we need to define it as a placeholder
like this
so now if we did the same request
you can see that it goes to the app and
it returns a redirect and it goes here
so now if we came and did a get request
for this
i'm gonna do a get
and the token is expired but let me go
ahead and get a new one
and we expect it to have updated the
visits count
because in this case we have actually
visited it
so i'm going to go here and change the
token
so if we do a get you can see that now
the visits are
one if we check it out again so i'm
gonna go here
so if we check it out again let me just
take this one again
and put it here okay and you can see
that now
if we do another get you guys that we've
checked it out
two times here
hey guys welcome back so now i want to
show you how we can gracefully
return json when we get errors like 404
so since this is a json on the api
it makes sense to just send json instead
of this html
so here in our app so in our app itself
over here we can have an error handler
so we can have app
we want to call error
handler so when you call error handler
you need to give it the code of the
error we want to handle or an exception
so that means that if you had a very
specific exception you want to be
sending
specific responses for you would add it
but for us you want to handle when a
user gets a
an http 404 not found and we are not
handling it
in that view in that view so if this is
the error that the app is running into
so just the same way we handle other
routes
we can define a function to handle this
so we will call this
handle for phone so we're just going to
be returning adjacent response so we're
just going to return the sonify
and then we're just going to say
obviously this is going to be throwing a
404
but since we are sending this one json
you can as well
explicitly define the type so it's going
to be for
form so whenever we create the handler
function we also need to pass the
exception
so i'm going to pass e here so that can
mean
anything now if we come back to our app
so i'm going to refresh here
i'm going to try to go to this endpoint
here so i'm going to refresh it
and now you can start to get json being
sent back to the user
so if we remove this
and we try to access this you can see
because that we get html so
if it's uh i just if it's a json on the
api
then it makes sense to you do something
like this
so we can also handle errors that come
from the server
so let's say the application is
collapsing for some reason so if 100
like
500 level errors so here we can just
handle server errors so http
500 nintendo server errors
then we can handle those similarly
by doing something went wrong please try
again
we are working on it
or something like that but whenever we
are doing something like this the intent
most of it mostly is not to
just tell the user this is happening of
course that is good
but we also would want to know that
these errors are happening in our
applications and we can find out
handling these
so the common case is to implement some
error reporting or error logging
so when an error like this happens we
send it to
like the admin of our app and the admin
can go ahead and check their looks and
can come and fix the area
that are generated into this air being
thrown
so if we come back here
so to test this obviously we need to
have an error in the application
so i'm going to go to the bookmarks and
let me see how to create an error
intentionally so for example on the
slash route
i'm just going to come in and say print
a
so we don't have a anywhere so this
should throw an application error
so if we go to api
slash it's gonna be api
slash bookmarks which is this one notice
so slash api slash bookmarks so right
now it is handling
so right now this is catching it but if
we remove something like this and we
come back here
make it go the same endpoint
so notice how the 500 error is not being
called by our android function
and the reason why this is the case is
because we are running into bug mode
but notice when i come here and show you
so notice how
notice when i come and change the flask
environment to production
so i'm going to go to a flask aim and
instead of us using development i'm just
going to change it to production just
for now
obviously we'll go into production we
need to change a lot of other things but
just to demonstrate the error
i'm going to stop that and run back the
server so the server is on
so we can still run this so now if i
refresh
you can see that we get something going
wrong and this
is now handling the the errors
so point note here is our handler for
the 500
will only work when we are running in
production
so these kinds of errors don't get
thrown to the user
hey guys welcome back so now we have
implemented link tracking
now let's go ahead and provide an
endpoint that can give us some
statistics
about how our links have been visited
so what we're going to do is here in our
bookmarks we're going to go down here
and we're going to have at bookmarks
when i have to get so i want to get when
a user goes to
stats and let's have a function it's
going to be
get stats so
for this one we basically are going to
be returning
a list and that list is going to be
containing a link
and how many times it was visited now
we're going to make a query
that will give us all the links for the
current login user
so we can do that by doing bookmark and
we want to do
query filter by so here let's
protect the endpoints make sure we have
the user so
that means we can get the current logged
user just as normal by doing get
generity identity
so here we can just do bookmark we can
do user id
this id should be the current user so if
you want all of them we can do dot on
or right and that's going to give us all
of them so now to get the links we're
just going to
loop over them and for each of them so
we're going to be getting the link stats
from each of these items and then we're
going to be adding it to our main
array so if for each of the items we're
going to create a
new a new link variable and that's going
to contain
a dictionary it's going to have visits
so for the visits we basically are going
to be checking link
dot visits now for the link the link
here is
gonna be item so let's also get the url
all right let's also send back the id
just so we need to work with it somehow
we can also send back our shorts
url so short so now that we have this we
can just append it to our data so we can
do data data
and we're going to be appending there
our new link and then outside the loop
then we can just return
just sonify then we can just do data
here then we can set that one to date
then we can just return
200 so http 200 okay save that let's
remove this and now if we go to our
postman
and try to go to slash bookmarks slash
stats
in the real world we need to refresh
that without having to tell the user
that it expires so we need to
we need to refresh it automatically for
the user so now
if i try that you can see that now we
get all our links sent back to us and
how many times
they were visited so that's how we
implement the start endpoint so in the
next one i'm going to be showing you how
to do some custom error and some error
handling
on our api as we are getting close to
winding up
hey guys welcome back so now we have
built all our endpoints
we have tested them out in postman now
what we are going to be doing is we are
going to go ahead and add documentation
for our api because yes we have built an
api we
have built our backend code but right
now it's only us that understands which
endpoints are on our server
and how they can be accessed so we need
a way to
tell other people about how our api is
what our api
is and how it is structured and how it
is it should be accessed
what parameters what urls we can expect
and we are going to be doing that by
describing it using
swagger so saga is just a set of tools
that can help us to describe and
document our api in a standard way
and that means that anyone who
understands the open api spec or the
swagger spec
can quickly understand what can quickly
read and understand what our api does
now i'm here on the swag io
specification
now i just scroll down to the things you
need to do to describe your api
so we need a way to define like what our
api is who is it for
if you have some terms of use we can
list those ones there
so we have to create something like this
so we can also define like a contact
object we should also have
have these uh compulsory or optional
fields like name uri and the email so
there's a license
we have the server object so we can
define like a base url
for our server so
yeah if you have multiple servers we
would specify something like this
so i'm going to scroll down just so you
can take a look at what else is
available so we also have the components
objects
this is mostly the things you're going
to be describing so how responses should
look how requests should look how the
requests should look
how how the headers should be what query
parameter
what query params should be there those
kinds of things so all this stuff
we are going to we are going to need to
create a document for
all these kinds of things now you notice
that
it's quite a lot here so to be able to
make a documentation for a flask app we
have different utilities that we can use
now depending on how you build your app
some of these tools can be able to
automatically pick up a documentation
but the way we are building our app we
are basically following a simple
a simple structure we are not using the
exteriorizers to handle our responses
so we're going to need to do some extra
setup notice that when you're using
first restful your documentation might
not look the same as you're going to
work to implement hours but later i'm
going to be
creating an api using fresh stressful
which is like an abstraction layer
and makes things more easy and much
better that these make things more easy
to work with
so right now for us to get started
documenting our own because either way
we need to
we need the word to tell the the whole
world
what our api is and how it can be
accessed we are going to be installing
this classical
and we are going to be manually
documenting our api
so first thing we're going to need to do
is to install it so i'm going to go to
the installation broke
so we need to install flask like this
setup tools we already have it
so here i'm going to stop the server
then we can install flask
flash gap okay they were so innovative
on the name
so once we installed flassica we need to
configure a few things
now here in our now here in our config
i'm going to create a file called saga
dot py so i'm going to bring in this
here and then we can go over it
so with flask we need to define a
template now you notice that
these are the things we are seeing in
the api spec
these are the things you are seeing here
in the specification
so here we need to define a template
where we can specify the info about our
api
so this is going to be standard you
don't really have to memorize all this
just need to know what they mean so
we're going to define a base path so we
don't want to be saying
it so we don't want to be our server api
v1 on every call
so we can define a base path and then
all the other urls
all the urls can be relative to this
so we also said that you can accept http
or https
so this part here is really important so
for the security definitions
there we defined that our api uses the
bearer type of authentication
and whenever a user and whenever a user
is making requests
the bare authentication with the type of
the api key and then we specify that
whenever a user is making a request
we need them to send us the
authorization in the header
understand and understands under
authorization of course it's going to be
the bearer type
and should be the jwt token okay so once
we define this outside the template
down here i'm going to bring in another
config
so for this config we basically define
like we basically define the initial
headers
now for the specs the api that we
generate here should be compatible
with other documentation tools so we
specify a route that we can use to get a
json version of our documentation which
we can move on to any other tool that
understands open api or swagger
and it should be able to work just fine
so then we define a static path
so this static path here is basically
used to generate the css to show on our
documentation
so don't mind much about that so we also
defined that we want to be using swagger
ui
so basically is foggy ui just lets us
visualize things
in a good one and we specify the default
route which is going to be at the home
page
so now from now every time we go to
homepage we should expect to see a
documentation
we need to configure this directly with
our app just so app can now understand
it
so what we need to do is
so what we need to do is in our data
init
so for that you're going to go here and
you put a few things from first gun
so we can do from flask
import paint
so we're gonna so we're gonna import
soda itself
we're also gonna import swan from so
swag from enables us to create a yaml
file where we can describe
our spec so once we import this we need
to go in that
in our config so over here you can also
pass a structure config
so swagger and then inside here we can
specify the title
so the title can be bookmarks api
and then we're going to specify the ui
version so the ui strategy ways have
brought now we can choose the one we
want to use i'm going to choose three
which is the current at the moment
so i suppose for ui version like that
let's create let's go ahead and from our
config import our swagger config
so from source.config
dot swagger imports
we need the template and also the other
server config we defined
so now down here before we return the
app
so i'm going to go here so right here we
can go ahead and
configure software so we're going to do
soccer and then we give it
the app so app is app then the next
thing i'm going to give it is our config
so for the config we'll just do config
serger config
and then we can pass the template so we
can do templates because the template we
defined in our config
so once we have this our setup will be
done now to start documenting
so we're going to start by documenting
this short url now
document this what we want is we want to
use the actuator
document attack from decorator you can
do a swipe from
and then we can specify the spec so in
our case we will need to specify the
path
to where our yaml file definition will
be
so here we are going to so here in our
web word i'm going to call it i'm going
to create a file called
docs and then inside docs i'm going to
have so i'm going to have each blueprint
and then inside you're going to be
putting the recommendations so let me
have both here
and let's start with login tiamo
so let's also create the one for
bookmarks i'm gonna do bookmarks
now there are some endpoints that are
not really in our apps for example this
one
so for this one what you can do is just
in the root
you can create a short url
but yammer since we are in the docs
folder should be able to work fine
and then inside here we can first define
what what it does
here you can say redirects to
so now here this is a yaml format so be
sure to make sure you're
you're consistent so want to define the
tags that this should have
now the tags are useful if you want to
group the urls in the documentation as
you'll see
so we can also specify parameters so
parameters
so for the parameters we can say okay
for someone to come here
we want first make sure that we want
first macro that's in the path
we have the short url and then we must
specify we can specify that this will be
required
so it can do required true with the ammo
true is not like a python true we use
the true like this
so also we can define like the responses
just so we can tell the people what they
can expect
so you can do responses and then we can
say that okay
when we get the three or two then that
means
then we can describe it so we can do
description
and guys everything here is uh
everything here is
down here but i'm just showing you like
a standard way you might do it
so you can see like here description and
all this stuff
so for the description then we can say
something like redirects
permanently also we can return a photo
form
and this can be thrown when the record
was not found or when the tag what that
should share was not
when that showed url was not found in
rdp okay
so this looks good to me i'm gonna go
ahead and save this file again
and then we run back our flask app so we
do flask
run so we need to change
our let me change our config to use
development again so i'm going to go to
our first game
and change this one to development
stop our server run it again so we need
to specify the swag here
now here we're gonna provide the path so
we're gonna do
dot slash docs slash short
just to make sure we we have a varied
path and now if you come back here and
refresh
it's still failing let's take a look at
why though we are defining our responses
we need to make sure that this is behind
so we have responses oh we need to have
this here yeah so you want to make sure
your yamo is formatted properly okay so
now we just need to make sure that our
things are correct
so we have this simple description we
have the tags
we have this we have our responses
we have our responses which should look
good so i'm gonna go back to the server
and now you can see that it works
without an error and yeah
and we have the the and we have the
the documentation for the slash shutter
route and we have even a way to try it
so the authorized button is when we
specify that we are using the br token
in this folder config
now what i want to do here is instead of
me going and doing things
scratch these dmo files are prone to me
making errors
so i'm going to show you how you can add
like the one for looking
so just a sec i'm gonna bring it in so
to make like the one for logging the one
that makes a post request
i'm going to bring in this and then over
here
you can see that we start we have a
simple description
then we have the tags so the tags are
used to group these endpoints
inside like this so you can see that the
shutter is grouped under
max so you can see that now we define
the parameters then for the name we say
okay in the body
we expect some things so we require a
username and a password
and then we give an example of how it
should look
and we can show some example responses
now you just need to make sure that your
your your yaml file is formatted
properly
and these keys are the ones that you
should expect so now
to add this to our route we can go to
for oauth and then where we have login
so we have login we can have swag from
so let's import sock from from classic
so from trust gun
so where we have the login
you can have swag from you can have that
sort from
and then we'll define the path so our
path here is going to be docs
slash auth slash
login.tml so let's save that
and now if we come back here and refresh
you can set we have the authentication
added and
because of the tags that it is grouped
the urls are grouped along
but if i went ahead to let's say here in
uh so let's say here in the login if i
went ahead and change this one to
bookmarks
and saved and refreshed here
you're gonna see that now everything is
under bookmarks so that's what tags are
they basically allow you to separate and
group related endpoints together
so let me also bring in the registration
it should be
quite similar to the login so here
i'm going to have register
with yama so it can be yammer like this
or yammer like this
so now it should be the same thing just
that here we expect three things
and they're all required we have an
example in there and the example
responses
so let's save that now we need to of
course add it to this
we need to have the swag from decorator
so i'm going to copy this
and uh here you can also have it
and this should be register but yeah
and uh if you come over here and refresh
you can see that register is also added
now i'm going to add
i'm going to add some few ones for the
bookmarks then i'm going to leave you
guys to add the other ones because the
format now you guys have the format
so i'm going to go ahead and add one
that can allow us to get the stats
i'm going to create a folder called
stats a file called stats
demo like this and then it's going to be
bookmark stats we expect the user to be
authenticated so we say okay
the authorization header is required and
these are the sample responses
so you can either send back this or the
bookmarks themselves
so now if we go to our app if we go to
our
bookmarks we can have swag from
which we should import here we need to
be able to go to
our stats and also add this work from
so here we can have a swag
from we'll find the path
blocks bookmarks stats
and if we save this so if we take a look
here you can see that it
is tagged under bookmarks and also let's
make it yammer
just so we have all our files are
consistent
so let's rename it here
yama let's save here
let's try again now you can see that it
is added it's added here
and things are good whenever we define a
documentation like this
it's going to have a spec now like we
said now we are basing on the open api
is spec
sometimes it's called swagger effect so
this is one that can be
understood by even other documentation
tools now if you look here we have the
api spec.json
so with this we can be able to export
this documentation into other tools
so i'm going to go to postman here and
with postman you see you can have
in the file you can have the imports
option so the import you can import this
documentation using our link
so we need to go to slash apispace.json
but we that is just a relative to our
domain so we are going to go to our app
and then enter the spec url and then we
can click continue
and this is going to detect that oh this
is a valid documentation
then we can import it in as a
documentation i'm going to click ok
and when i do that we get an api and the
correction imported
then i'm going to close here and when
this refreshes you can set now we have
the bookmarks api
and yeah so down here if you click on
this
we should be able to see the
documentation so the more we add
more docs more more endpoints on here
the more we can get more when we export
so for the collection if i click on
correction we have this
new bookmark set we have this new
bookmarks
api and this can be used to
to test out apis really fast
so that is the basics of how we can
document our simple api
now i'm looking forward to creating more
tutorials that we use
that will use flash restful and we're
going to be seeing how we can work with
that
first restful and the api documentation
so if this
video helps you please give it a thumbs
up don't forget to subscribe
i'll see you in the next one where we
are going to be
i'll travel something other channel yeah
where we're going to be
deploying this application to the live
server so thanks guys for watching
hey guys welcome to the last video in
the series so in this one we are going
to be deploying our flask application
to heroku that way we can share a url to
other developers and they can build apps
for our api
so to get started we are going to need
to first change a few things
one is we are going to need a git
repository so heroku uses git to manage
deploys
so you want to make sure you're using
git for local version control
and in our case you're going to be using
github so make sure you have a github
account that you can
push your code to so i'm going to be
showing you a process on how we can do
that
now here in my terminal this is our
project
and to redirect we have uh the data init
py file
so that is where our application lives
we have the create
app factory function so to get started
i'm going to stop the server here
now the first thing we're going to need
to do is we're going to need to first
get a server that will serve our
application
on heroku so in our case we are going to
be using g unicorn
so i'm going to install it quickly here
by doing clip install
g unicorn and that's gonna go ahead and
install it
so now we have that so with heroku we
can be able to customize
how it runs our applications through
using a file code profile
so in the root of our projects i'm going
to specify a file called brocfire
now you can see that that has the hero
button there so what we need to change
here is we need to specify
the command that's going to run our
application now since we've installed g
unicorn we're going to be
you're going to be making it run our
application so do your unicorn
so you you type junicon and then you
type your path
to your application so
our path for now is uh data in it
so what i want to do is here in uh is
here
in our root i'm going to create a file
called runner.py
and this is going to be meant for just
deployment
so here we can import our app okay so
here you can define app
application equals create app then
you're gonna instantiate it
because that is that is how it gets
assigned to
the app one around so we wanna run this
application now
with unicorn and you can do that by
specifying a path
so in our case it's going to be in uh
source
dot runner then the application so we
can specify that by doing src
runner full current then the name of our
main application is called application
test this one out so i'm going to copy
this command
and inside the terminal here i'm going
to paste it
so this is how hierarchy is going to run
this notice that when i paste the
command here the exact command that we
want heroku to run
we get a server started and by default
it's going to start on the default http
port
so in our case we can see that when we
run this
we get a gene code running and then we
get this link here
so when i click this you can see that it
has the same version as our development
server now of course when you're
deploying you want to
also take care of some things for
example if you had a db you want to
connect to one production you would do
that but in our case we're just going to
keep our
secret db since we already have it so
we're gonna commit it to kid and
we just keep it working like that but
you have to have uh
like a database setup if you're using
something else like mysql
or postgre so now that we have this the
next thing i'm gonna need to do is to
tell
eroku which dependencies our application
needs so i'm going to stop the server
now since we're using pip we can use
feedfreeze
to create a file that has our
dependencies so that's why we're going
to create requirements.txt
so if we do this we get through gram and
cxt file
created and it has all our project
dependencies
so now that we are done with that then
we can create a git repository
for our project now since we don't have
any git repositories in
initiated locally yet we're going to
start by creating it on github
because you're going to need to push to
github so over here i'm going to
click new repository i'm going to query
our application
bookmarker api
so once we have that then i'm just going
to create it it's going to be public
and this is where all this was good for
the series it's going to provide now
that you've created it i'm going to copy
these default commands they give me and
to make it quick i'm just gonna
put it here so that's gonna initialize a
git repository locally
and it's gonna push a default file which
is readme now so if i refresh on github
we should have the readme you can see we
have the readme
so the next thing i'm going to need to
do now is to actually push
our code but like i was saying we need
to first also change our environment
just so we can change that we're running
we are now running to in production so
what we're going to do here is the first
app
we shouldn't mind it everything here is
going to be used for
for development our run-up process is
going to be running our app differently
since we set it up to use g unicorn so
we can keep this and then in heroku i'm
going to show you how you can add them
dynamically
so over here now we are going to get
checkout
i'm going to create another branch for
the one of this i want this to come
through a pull request
so i'm going to call this one deploy
app then we can add the changes so bit
add
everything so before we add everything
we have a dot envy file
and we don't have a git ignore file so
i'm gonna go online here
to dot git ignore
so this helps us to quickly create git
ignore files for
for the common technologies so if i put
in flask
and click create and see that we get
like a general dedicated notifier
so let me create it here it's ignorant
so i'm going to bring in all this now
let me remove this
so this should be able to hide our watch
environments
and everything that should be sensitive
so if we do a git status
we should be able to see that we have
all these files
now we need to remove our dot m this
main dot m that has things we shouldn't
commit
so over here we can remove it by doing
it rm
crashed dot env
because it gets removed so if you do a
git status again
uh you can see that it's gone so now we
can go ahead and add this change the
staging area and then commit
everything so git add the git ignore
and then let's ah and then let's commit
so git commit minus m
put a message
up so now we can do a push to github
so i'm gonna come over here
and use this setup stream just so
our subsequent pushes got this this
branch
so now i'm going to click on the create
a pull request link
and i'm just going to create it normally
you want to fill out all this just so
maybe
if you need to check something in the
future you can drag back and see okay
what was i thinking at this point in
time
so i'm just going to match it for now if
you get any issues we are going to
come back and actually resolve them so
now when we push to main
you can see that we have a requirements
file which europe is going to need
and also we have the we have the first
game
now for the first game we are going to
need to switch them in here so don't
worry about these ones being here
so now in heroku we can come here and
create a new app so i'm going to call
this one
how did you call it github let me check
just want to make sure it is the same
doesn't really matter just make sure you
have a name
and and if it's available then good for
you so i'm just going to say
rest at the end then i'm going to click
create app so when we create
app we can go to the deeper section we
want to click connect
github if you're not logged if you
hadn't authenticated before it's gonna
tell you to log in
so after you log in you're gonna have
your your accounts here
and then we want to search for the one
who wants to deploy to
so when i type in bookmarker api you can
see that it comes through
and then i can click connect so when i
click connect it's going to go and run
now it gets the branches then we are
going to go ahead and
deploy this branch so i'm going to go
ahead and click the pro branch
and then it's going to go ahead and now
start installing the things it needs
so it's going to detect that we are
running python and then it's going to go
ahead and
start installing things in the premise
txt so now that the deployment is done
we're going to see that the app was
successfully deployed
if we if we click on view it's going to
open up in a new tab
and right now you can see that we have a
title that we would want to see
so that means the application was able
to be deployed and it's being saved
so after that you're going to see that
now it gets ahead to be rendered here
now things are not going to be working
yet because we still need to do some
config
for example you see if i try to make a
call you can see that we get this error
in fact i'm going to copy this and go to
postman
so in postman i'm going to make another
request it's going to be a post
so if we try to do this you can see that
we get a 500
and we actually don't get more errors
since now we are running in a production
environment
so what you need to do is actually set
up these environments
so the way heroku does it is for the
things we define in flask m
they try to look for them in their
environment inside our hero code so to
set the secret key
we need to have something that is really
sacred and
that can be added to guess so i'm gonna
go to
my terminal and then i'm going to use
this utility that is provided in the
first website
so what it does is basically input os
and then it uses os to give us
and then it gives us a 16 random string
that you can use so i'm just going to
copy the
this format here and then inside heroku
you want to go to
settings so when you go to settings then
you will see
configures so for this
then we need to set the keys so this is
going to be
secret underscore okay
here the other things we need to set
and the sequel argument url
so go back to heroku let's add this
so let's set the secret to the dp url
it's going to be the same
because we can use the same if you're
using something like mysql or postgres
you're going to have your own
db url in fact if you're using postgres
heroku kind of gives you the
db url directly even when you're debris
for the first time
that's the one you want to put here so
let's go ahead and
also add our url
so let's also add a jwt secret
so copy this so for this secret it can
be anything
so this time we are not going to
generate 16 just generate eight
so we get this uh we just copy any parts
any substring is okay
just have something to work with and now
when we save this
and we go back to our postman so since
they don't give us a lot of information
i'm going to go to the body and send
like real data so i'm going to click row
then i need to choose json
[Music]
so then in here now we can send the
username
so let's have username as username
let's have the password
as the password as the username doesn't
matter
and for the email it's going to have
something that is invalid
so if i try to send this notice that we
get email is not valid
and this signifies that our api is
actually working so i'm going to go
ahead and
make a valid email so gmail.com
send this username is taken so let's use
username56 send this
now you can see user created so we're
just going to go to the login endpoint
just to make sure that we can log in and
you can set we can log in we get the
access token and the refresh token
meaning that our jwt secret key is being
picked up
so i'm going to pick this so i'm going
to go to a new url
and here i'm going to try to access the
i'm going to try to access the bookmarks
so those are on bookmarks
now we need to send our jwt that we put
on login
so i'm going to copy this here from
access
then the auth we want to pick bear a
token
then we want to send albert okay forget
the one that was revealed in mind
sometimes it gets preferred but just put
your new one so you can see that we get
our results being sent back to us
if we go to body and do a poster and
we need to post json of course so we
need to send the url and then the button
so let's try to send this so you get the
url is not valid
now i'm just going to pick a random url
on the internet so let me just
get a random one let me pick this here
so i'm going to go to postman
let's send a url yes me put
flask box
so if i go ahead and click send
because we get it's created now if we go
and do a gate again you can set we get
it listed so that means that our api is
even working even on prod
and also we have our short url so now if
i went to
our flask app if i went to a flask app
here slash this url and by the way if
you guys ever wondered how
url certain as work imagine imagine we
had a domain that was like abc.com
it would mean that we are able to
translate
in a url into less than seven
characters so imagine we had like
bookmarks api hero
app was like abc.com so that's how they
do it now
here if we try to get this we expect to
be taken to this
first config and that is what's
happening so our progression is up and
running
there might be some things that are not
working good so if you guys ever find an
issue be sure to
leave a comment and people are going to
be happy to take a look
so thanks guys for watching i hope this
was helpful if it was
give it a thumbs up don't forget to sub
i'll talk to you later

